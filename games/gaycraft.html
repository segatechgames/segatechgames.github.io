<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GayCraft 2.0.0</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Arial', sans-serif; }
        canvas { display: block; }
        #ui { position: fixed; top: 0; left: 0; padding: 1rem; z-index: 100; color: white; pointer-events: none; }
        #blockPicker { background: rgba(0,0,0,0.7); padding: 0.5rem; border-radius: 4px; pointer-events: all; }
        #watermark { position: fixed; top: 10px; right: 10px; font-size: 1.5em; font-weight: bold;
            background: linear-gradient(90deg, #ff0000, #ff8000, #ffff00, #00ff00, #00ffff, #8000ff);
            -webkit-background-clip: text; background-clip: text; color: transparent; }
        #crosshair { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            width: 4px; height: 4px; background: rgba(255,255,255,0.9); border-radius: 50%; }
        #optionsMenu { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            background: rgba(0,0,0,0.9); padding: 1.5rem; border-radius: 8px; color: white; display: none;
            gap: 0.5rem; flex-direction: column; z-index: 1000; pointer-events: all; }
        button { padding: 0.5rem 1rem; background: #444; border: none; color: white; border-radius: 4px;
            cursor: pointer; transition: background 0.2s; }
        button:hover { background: #666; }
        select { padding: 0.25rem; background: #333; color: white; border: none; border-radius: 3px; }
        #fileInput { display: none; }
        #loadingScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background-color: #886633; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 2000; }
        #loadingProgress { width: 300px; height: 20px; background: #333; margin-top: 20px; }
        #loadingBar { height: 100%; width: 0%; background: #55aa44; }
        #welcomePopup { background: rgba(0,0,0,0.8); color: white; padding: 2rem; 
            border-radius: 8px; max-width: 500px; text-align: center; }
        #welcomePopup h2 { margin-bottom: 1rem; }
        #welcomePopup ul { text-align: left; margin: 1rem 0; }
        #startButton { margin-top: 1rem; padding: 0.75rem 1.5rem; font-size: 1.2rem; }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div id="welcomePopup">
            <h2>Welcome to GayCraft 2.0!</h2>
            <p>Controls:</p>
            <ul>
                <li><strong>WASD</strong> - Move forward/left/back/right</li>
                <li><strong>Space</strong> - Jump</li>
                <li><strong>Mouse</strong> - Look around</li>
                <li><strong>Left Click</strong> - Break block</li>
                <li><strong>Right Click</strong> - Place block</li>
                <li><strong>M</strong> - Open menu</li>
            </ul>
            <p>The world will generate around you as you explore!</p>
            <button id="startButton">Start Game</button>
        </div>
        <div id="loadingProgress">
            <div id="loadingBar"></div>
        </div>
    </div>

    <div id="ui">
        <div id="blockPicker">
            Block: <select id="blockType">
                <option value="grass">Grass</option>
                <option value="stone">Stone</option>
                <option value="dirt">Dirt</option>
                <option value="sand">Sand</option>
                <option value="wood">Wood</option>
                <option value="leaves">Leaves</option>
            </select>
        </div>
        <div id="watermark">GayCraft 2.0</div>
    </div>
    <div id="crosshair"></div>
    <div id="optionsMenu">
        <button id="saveBtn">Save Game</button>
        <button id="loadBtn">Load Game</button>
        <button onclick="window.location.href='https://segatechgames.github.io/'">Exit</button>
        <button onclick="closeOptions()">Close</button>
    </div>
    <input type="file" id="fileInput" accept=".gaycraft"/>

    <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

    <script>
        // Game Configuration
        const CONFIG = {
            CHUNK_SIZE: 16,
            RENDER_DISTANCE: 6,
            PLAYER_HEIGHT: 1.8,
            MOVEMENT_SPEED: 0.15,
            JUMP_FORCE: 0.35,
            GRAVITY: 0.02,
            MOUSE_SENSITIVITY: 0.002,
            TREE_DENSITY: 0.02,
            WORLD_HEIGHT: 64,
            SEED: Math.floor(Math.random() * 999999)
        };

        // Game State
        let scene, camera, renderer;
        let world = new Map();
        let chunks = new Map();
        let activeChunks = new Set();
        let materials = {};
        let blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        let player = { 
            position: new THREE.Vector3(0, 70, 0),
            velocity: new THREE.Vector3(),
            yaw: 0,
            pitch: 0,
            onGround: false
        };
        let keys = {};
        let raycaster = new THREE.Raycaster();
        let loading = true;
        let chunksToGenerate = [];

        // Initialize Game
        function initGame() {
            try {
                // Scene Setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87ceeb);
                
                // Camera Setup
                camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                
                // Renderer Setup
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                // Materials
                materials = {
                    grass: new THREE.MeshLambertMaterial({ color: 0x55aa44 }),
                    stone: new THREE.MeshLambertMaterial({ color: 0x999999 }),
                    dirt: new THREE.MeshLambertMaterial({ color: 0x886633 }),
                    sand: new THREE.MeshLambertMaterial({ color: 0xffdd99 }),
                    wood: new THREE.MeshLambertMaterial({ color: 0x774411 }),
                    leaves: new THREE.MeshLambertMaterial({ color: 0x33aa33, transparent: true, opacity: 0.8 })
                };

                // Lighting
                scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(100, 100, 50);
                scene.add(directionalLight);

                // Setup player position properly
                findSpawnPosition();
                camera.position.copy(player.position);
                
                // Setup controls and UI
                setupEventListeners();
                setupMenuButtons();
                
                // Start loading initial chunks
                startLoading();

            } catch (error) {
                console.error("Initialization error:", error);
                alert("Game failed to initialize. Check console for details.");
            }
        }

        function findSpawnPosition() {
            // Find a suitable spawn position above ground
            for (let x = 0; x < 16; x++) {
                for (let z = 0; z < 16; z++) {
                    const height = getTerrainHeight(x, z);
                    if (height > 60) {
                        player.position.set(x, height + 2, z);
                        return;
                    }
                }
            }
        }

        function startLoading() {
            // Initial chunk loading
            updateChunks();
            
            // Start loading animation
            const totalChunks = Math.pow(CONFIG.RENDER_DISTANCE * 2 + 1, 2);
            let loaded = 0;
            
            const loadingInterval = setInterval(() => {
                generateNextChunk();
                loaded++;
                
                // Update progress bar
                const progress = Math.min(100, Math.floor((loaded / totalChunks) * 100));
                document.getElementById('loadingBar').style.width = `${progress}%`;
                
                if (loaded >= totalChunks) {
                    clearInterval(loadingInterval);
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        loading = false;
                        animate();
                    }, 500);
                }
            }, 50);
        }

        function generateNextChunk() {
            if (chunksToGenerate.length === 0) return;
            
            const chunkKey = chunksToGenerate.shift();
            generateChunk(chunkKey);
        }

        // World Generation
        function getTerrainHeight(x, z) {
            // Simple noise-based terrain
            const scale = 0.1;
            const heightScale = 20;
            const baseHeight = 60;
            
            const noise = Math.abs(perlin.get((x + CONFIG.SEED) * scale, (z + CONFIG.SEED) * scale));
            return Math.floor(baseHeight + noise * heightScale);
        }

        function generateChunk(chunkKey) {
            if (chunks.has(chunkKey)) return;
            
            const [chunkX, chunkZ] = chunkKey.split(',').map(Number);
            const chunkGroup = new THREE.Group();
            scene.add(chunkGroup);
            chunks.set(chunkKey, chunkGroup);
            
            // Generate terrain for this chunk
            for (let x = chunkX * CONFIG.CHUNK_SIZE; x < (chunkX + 1) * CONFIG.CHUNK_SIZE; x++) {
                for (let z = chunkZ * CONFIG.CHUNK_SIZE; z < (chunkZ + 1) * CONFIG.CHUNK_SIZE; z++) {
                    const height = getTerrainHeight(x, z);
                    
                    // Ground layers
                    addBlock(x, height, z, 'grass', chunkGroup);
                    addBlock(x, height-1, z, 'dirt', chunkGroup);
                    for (let y = height-2; y >= height-4; y--) {
                        addBlock(x, y, z, 'dirt', chunkGroup);
                    }
                    for (let y = height-5; y >= 0; y--) {
                        addBlock(x, y, z, 'stone', chunkGroup);
                    }

                    // Random trees
                    if (height > 60 && Math.random() < CONFIG.TREE_DENSITY && x % 3 === 0 && z % 3 === 0) {
                        generateTree(x, height+1, z, chunkGroup);
                    }
                }
            }
        }

        function generateTree(x, y, z, chunkGroup) {
            // Trunk
            for (let i = 0; i < 5; i++) {
                addBlock(x, y+i, z, 'wood', chunkGroup);
            }
            
            // Leaves
            for (let ly = 3; ly <= 5; ly++) {
                const radius = ly === 5 ? 1 : 2;
                for (let lx = -radius; lx <= radius; lx++) {
                    for (let lz = -radius; lz <= radius; lz++) {
                        if (ly === 5 && (lx === 0 || lz === 0)) continue;
                        addBlock(x+lx, y+ly, z+lz, 'leaves', chunkGroup);
                    }
                }
            }
        }

        function addBlock(x, y, z, type, chunkGroup) {
            const key = `${x},${y},${z}`;
            if (world.has(key)) return;
            
            const block = new THREE.Mesh(blockGeometry, materials[type]);
            block.position.set(x, y, z);
            block.userData = { type };
            chunkGroup.add(block);
            world.set(key, block);
        }

        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            if (!world.has(key)) return;
            
            const block = world.get(key);
            block.parent.remove(block);
            world.delete(key);
        }

        // Chunk Management
        function updateChunks() {
            const playerChunkX = Math.floor(player.position.x / CONFIG.CHUNK_SIZE);
            const playerChunkZ = Math.floor(player.position.z / CONFIG.CHUNK_SIZE);
            
            // Determine which chunks should be active
            const newActiveChunks = new Set();
            chunksToGenerate = [];
            
            for (let x = playerChunkX - CONFIG.RENDER_DISTANCE; x <= playerChunkX + CONFIG.RENDER_DISTANCE; x++) {
                for (let z = playerChunkZ - CONFIG.RENDER_DISTANCE; z <= playerChunkZ + CONFIG.RENDER_DISTANCE; z++) {
                    const chunkKey = `${x},${z}`;
                    newActiveChunks.add(chunkKey);
                    
                    if (!chunks.has(chunkKey)) {
                        chunksToGenerate.push(chunkKey);
                    }
                }
            }
            
            // Unload distant chunks
            activeChunks.forEach(chunkKey => {
                if (!newActiveChunks.has(chunkKey)) {
                    const chunk = chunks.get(chunkKey);
                    if (chunk) {
                        scene.remove(chunk);
                        chunks.delete(chunkKey);
                    }
                }
            });
            
            activeChunks = newActiveChunks;
        }

        // Player Movement
        function updatePlayer(deltaTime) {
            // Fixed controls (no longer backwards)
            const forward = new THREE.Vector3(
                -Math.sin(player.yaw),
                0,
                -Math.cos(player.yaw)
            );
            const right = new THREE.Vector3(
                -Math.cos(player.yaw),
                0,
                Math.sin(player.yaw)
            );

            // Movement
            const move = new THREE.Vector3();
            if (keys.w) move.add(forward);
            if (keys.s) move.sub(forward);
            if (keys.a) move.sub(right);
            if (keys.d) move.add(right);

            move.normalize().multiplyScalar(CONFIG.MOVEMENT_SPEED);
            
            // Check horizontal collisions
            const testPos = player.position.clone().add(new THREE.Vector3(move.x, 0, move.z));
            if (!checkCollision(testPos)) {
                player.position.x = testPos.x;
                player.position.z = testPos.z;
            }

            // Gravity
            player.velocity.y -= CONFIG.GRAVITY;
            const verticalTest = player.position.clone().add(new THREE.Vector3(0, player.velocity.y, 0));
            
            // Check vertical collisions
            if (!checkCollision(verticalTest)) {
                player.position.y = verticalTest.y;
                player.onGround = false;
            } else {
                player.velocity.y = 0;
                player.onGround = true;
            }

            // Jumping
            if (keys[' '] && player.onGround) {
                player.velocity.y = CONFIG.JUMP_FORCE;
                player.onGround = false;
            }

            // Update camera
            camera.position.copy(player.position);
            camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
            
            // Update chunks if needed
            const playerChunkX = Math.floor(player.position.x / CONFIG.CHUNK_SIZE);
            const playerChunkZ = Math.floor(player.position.z / CONFIG.CHUNK_SIZE);
            const playerChunkKey = `${playerChunkX},${playerChunkZ}`;
            
            if (!activeChunks.has(playerChunkKey)) {
                updateChunks();
            }
            
            // Generate chunks in background
            if (chunksToGenerate.length > 0 && !loading) {
                generateNextChunk();
            }
        }

        function checkCollision(position) {
            const playerBox = new THREE.Box3(
                new THREE.Vector3().copy(position).sub(new THREE.Vector3(0.3, 0, 0.3)),
                new THREE.Vector3().copy(position).add(new THREE.Vector3(0.3, CONFIG.PLAYER_HEIGHT, 0.3))
            );

            // Only check nearby blocks
            const minX = Math.floor(position.x - 1);
            const maxX = Math.ceil(position.x + 1);
            const minY = Math.floor(position.y - 1);
            const maxY = Math.ceil(position.y + CONFIG.PLAYER_HEIGHT + 1);
            const minZ = Math.floor(position.z - 1);
            const maxZ = Math.ceil(position.z + 1);

            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        const key = `${x},${y},${z}`;
                        if (world.has(key)) {
                            const block = world.get(key);
                            const blockBox = new THREE.Box3().setFromObject(block);
                            if (playerBox.intersectsBox(blockBox)) return true;
                        }
                    }
                }
            }
            return false;
        }

        // Event Listeners
        function setupEventListeners() {
            document.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;
                if (e.key === 'm') toggleOptions();
            });
            
            document.addEventListener('keyup', e => {
                keys[e.key.toLowerCase()] = false;
            });
            
            document.addEventListener('click', () => {
                if (!document.pointerLockElement) {
                    document.body.requestPointerLock();
                } else {
                    handleBlockInteraction();
                }
            });

            document.addEventListener('mousemove', e => {
                if (document.pointerLockElement === document.body) {
                    player.yaw -= e.movementX * CONFIG.MOUSE_SENSITIVITY;
                    player.pitch -= e.movementY * CONFIG.MOUSE_SENSITIVITY;
                    player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.pitch));
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            document.getElementById('startButton').addEventListener('click', initGame);
        }

        function setupMenuButtons() {
            document.getElementById('saveBtn').addEventListener('click', saveGameToFile);
            document.getElementById('loadBtn').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });
            
            document.getElementById('fileInput').addEventListener('change', loadGameFromFile);
        }

        function handleBlockInteraction() {
            raycaster.setFromCamera(new THREE.Vector2(), camera);
            const intersects = raycaster.intersectObjects([...world.values()]);
            
            if (intersects.length > 0) {
                const block = intersects[0].object;
                const type = document.getElementById('blockType').value;
                
                if (event.button === 0) { // Left click - break block
                    removeBlock(block.position.x, block.position.y, block.position.z);
                } else if (event.button === 2) { // Right click - place block
                    const faceNormal = intersects[0].face.normal;
                    const pos = block.position.clone().add(faceNormal);
                    
                    // Find which chunk this should go in
                    const chunkX = Math.floor(pos.x / CONFIG.CHUNK_SIZE);
                    const chunkZ = Math.floor(pos.z / CONFIG.CHUNK_SIZE);
                    const chunkKey = `${chunkX},${chunkZ}`;
                    
                    if (chunks.has(chunkKey)) {
                        addBlock(pos.x, pos.y, pos.z, type, chunks.get(chunkKey));
                    }
                }
            }
        }

        function toggleOptions() {
            const menu = document.getElementById('optionsMenu');
            menu.style.display = menu.style.display === 'flex' ? 'none' : 'flex';
        }

        function closeOptions() {
            document.getElementById('optionsMenu').style.display = 'none';
        }

        function saveGameToFile() {
            const data = {
                player: {
                    position: player.position.toArray(),
                    yaw: player.yaw,
                    pitch: player.pitch
                },
                world: Array.from(world.entries()).map(([key, block]) => ({
                    key,
                    type: block.userData.type,
                    position: block.position.toArray()
                })),
                seed: CONFIG.SEED
            };
            
            const compressed = LZString.compress(JSON.stringify(data));
            const blob = new Blob([compressed], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `gaycraft_save_${new Date().toISOString().slice(0,10)}.gaycraft`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('Game saved to file!');
        }

        function loadGameFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const compressed = e.target.result;
                    const data = JSON.parse(LZString.decompress(compressed));
                    
                    // Clear existing world
                    world.forEach(block => {
                        if (block.parent) block.parent.remove(block);
                    });
                    world.clear();
                    chunks.clear();
                    activeChunks.clear();
                    
                    // Set seed
                    CONFIG.SEED = data.seed || Math.floor(Math.random() * 999999);
                    
                    // Load player state
                    player.position.fromArray(data.player.position);
                    player.yaw = data.player.yaw;
                    player.pitch = data.player.pitch;
                    
                    // Update camera
                    camera.position.copy(player.position);
                    
                    // Regenerate world around player
                    updateChunks();
                    
                    alert('Game loaded from file!');
                } catch(e) {
                    console.error('Load error:', e);
                    alert('Failed to load game file!');
                }
            };
            reader.readAsText(file);
        }

        // Simple Perlin noise implementation for terrain generation
        const perlin = {
            rand_vect: function() {
                const theta = Math.random() * 2 * Math.PI;
                return {x: Math.cos(theta), y: Math.sin(theta)};
            },
            dot_prod_grid: function(x, y, vx, vy) {
                let g_vect;
                const d_vect = {x: x - vx, y: y - vy};
                if (this.gradients[[vx,vy]]) {
                    g_vect = this.gradients[[vx,vy]];
                } else {
                    g_vect = this.rand_vect();
                    this.gradients[[vx, vy]] = g_vect;
                }
                return d_vect.x * g_vect.x + d_vect.y * g_vect.y;
            },
            smootherstep: function(x) {
                return 6*x**5 - 15*x**4 + 10*x**3;
            },
            interp: function(x, a, b) {
                return a + this.smootherstep(x) * (b-a);
            },
            gradients: {},
            get: function(x, y) {
                const xf = Math.floor(x);
                const yf = Math.floor(y);
                // Interpolate
                const tl = this.dot_prod_grid(x, y, xf,   yf);
                const tr = this.dot_prod_grid(x, y, xf+1, yf);
                const bl = this.dot_prod_grid(x, y, xf,   yf+1);
                const br = this.dot_prod_grid(x, y, xf+1, yf+1);
                const xt = this.interp(x-xf, tl, tr);
                const xb = this.interp(x-xf, bl, br);
                return this.interp(y-yf, xt, xb);
            }
        };

        // Game Loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (!loading) {
                updatePlayer(0.016); // Fixed delta time
                renderer.render(scene, camera);
            }
        }
    </script>
</body>
</html>
