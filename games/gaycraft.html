<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GayCraft 2.2.0</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Arial', sans-serif; }
        canvas { display: block; }
        #ui { position: fixed; top: 0; left: 0; padding: 1rem; z-index: 100; color: white; pointer-events: none; }
        #blockPicker { background: rgba(0,0,0,0.7); padding: 0.5rem; border-radius: 4px; pointer-events: all; }
        #watermark { position: fixed; top: 10px; right: 10px; font-size: 1.5em; font-weight: bold;
            background: linear-gradient(90deg, #ff0000, #ff8000, #ffff00, #00ff00, #00ffff, #8000ff);
            -webkit-background-clip: text; background-clip: text; color: transparent; }
        #crosshair { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            width: 4px; height: 4px; background: rgba(255,255,255,0.9); border-radius: 50%; }
        #optionsMenu { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            background: rgba(0,0,0,0.9); padding: 1.5rem; border-radius: 8px; color: white; display: none;
            gap: 0.5rem; flex-direction: column; z-index: 1000; pointer-events: all; }
        button { padding: 0.5rem 1rem; background: #444; border: none; color: white; border-radius: 4px;
            cursor: pointer; transition: background 0.2s; }
        button:hover { background: #666; }
        select { padding: 0.25rem; background: #333; color: white; border: none; border-radius: 3px; }
        #fileInput { display: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="blockPicker">
            Block: <select id="blockType">
                <option value="grass">Grass</option>
                <option value="stone">Stone</option>
                <option value="dirt">Dirt</option>
                <option value="sand">Sand</option>
                <option value="wood">Wood</option>
                <option value="leaves">Leaves</option>
            </select>
        </div>
        <div id="watermark">GayCraft 2.0</div>
    </div>
    <div id="crosshair"></div>
    <div id="optionsMenu">
        <button id="saveBtn">Save Game</button>
        <button id="loadBtn">Load Game</button>
        <button onclick="window.location.href='https://segatechgames.github.io/'">Exit</button>
        <button onclick="closeOptions()">Close</button>
    </div>
    <input type="file" id="fileInput" accept=".gaycraft"/>

    <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

    <script>
        // Optimized Configuration
        const CONFIG = {
            WORLD_SIZE: 64,
            PLAYER_HEIGHT: 1.8,
            MOVEMENT_SPEED: 0.15,
            JUMP_FORCE: 0.35,
            GRAVITY: 0.02,
            MOUSE_SENSITIVITY: 0.002,
            TREE_DENSITY: 0.02,
            RENDER_DISTANCE: 32,
            CHUNK_SIZE: 16
        };

        // Core Game State
        let scene, camera, renderer, world = new Map();
        let chunks = new Map();
        let player = { 
            position: new THREE.Vector3(0, 32, 0),
            velocity: new THREE.Vector3(),
            yaw: 0,
            pitch: 0,
            onGround: false,
            inventory: {}
        };
        let keys = {}, mouseDelta = new THREE.Vector2(), raycaster = new THREE.Raycaster();
        let materials = {};
        let blockGeometry = new THREE.BoxGeometry(1, 1, 1);

        // Initialize Game
        function init() {
            try {
                // Scene Setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87ceeb);
                
                // Camera Setup
                camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.copy(player.position);
                
                // Renderer Setup with performance hints
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                // Preload materials
                materials = {
                    grass: new THREE.MeshLambertMaterial({ color: 0x55aa44 }),
                    stone: new THREE.MeshLambertMaterial({ color: 0x999999 }),
                    dirt: new THREE.MeshLambertMaterial({ color: 0x886633 }),
                    sand: new THREE.MeshLambertMaterial({ color: 0xffdd99 }),
                    wood: new THREE.MeshLambertMaterial({ color: 0x774411 }),
                    leaves: new THREE.MeshLambertMaterial({ color: 0x33aa33, transparent: true, opacity: 0.8 })
                };

                // Optimized Lighting
                scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(100, 100, 50);
                scene.add(directionalLight);

                // Generate Optimized World
                generateOptimizedWorld();
                setupEventListeners();
                setupMenuButtons();
                animate();

            } catch (error) {
                console.error("Initialization error:", error);
                alert("Game failed to initialize. Check console for details.");
            }
        }

        // Optimized World Generation with Chunk System
        function generateOptimizedWorld() {
            // Generate terrain with height variation
            for(let x = -CONFIG.WORLD_SIZE; x <= CONFIG.WORLD_SIZE; x++) {
                for(let z = -CONFIG.WORLD_SIZE; z <= CONFIG.WORLD_SIZE; z++) {
                    // Create height variation
                    const height = Math.floor(Math.sin(x/10) * Math.cos(z/10) * 3) + 5;
                    
                    // Ground layers
                    addBlock(x, height, z, 'grass');
                    addBlock(x, height-1, z, 'dirt');
                    for(let y = height-2; y >= height-4; y--) {
                        addBlock(x, y, z, 'dirt');
                    }
                    for(let y = height-5; y >= -5; y--) {
                        addBlock(x, y, z, 'stone');
                    }

                    // Random trees (optimized generation)
                    if(Math.random() < CONFIG.TREE_DENSITY && height > 0 && x % 3 === 0 && z % 3 === 0) {
                        generateTree(x, height+1, z);
                    }
                }
            }
        }

        // Optimized Tree Generator
        function generateTree(x, y, z) {
            // Trunk
            for(let i = 0; i < 5; i++) {
                addBlock(x, y+i, z, 'wood');
            }
            
            // Leaves - optimized pattern
            for(let ly = 3; ly <= 5; ly++) {
                const radius = ly === 5 ? 1 : 2;
                for(let lx = -radius; lx <= radius; lx++) {
                    for(let lz = -radius; lz <= radius; lz++) {
                        if(ly === 5 && (lx === 0 || lz === 0)) continue;
                        addBlock(x+lx, y+ly, z+lz, 'leaves');
                    }
                }
            }
        }

        // Optimized Block Management with Chunk System
        function addBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            if(world.has(key)) return;

            // Get chunk coordinates
            const chunkX = Math.floor(x / CONFIG.CHUNK_SIZE);
            const chunkZ = Math.floor(z / CONFIG.CHUNK_SIZE);
            const chunkKey = `${chunkX},${chunkZ}`;
            
            // Create chunk if it doesn't exist
            if(!chunks.has(chunkKey)) {
                const chunkGroup = new THREE.Group();
                scene.add(chunkGroup);
                chunks.set(chunkKey, chunkGroup);
            }
            
            const chunk = chunks.get(chunkKey);
            const block = new THREE.Mesh(blockGeometry, materials[type]);
            block.position.set(x, y, z);
            block.userData = { type };
            chunk.add(block);
            world.set(key, block);
        }

        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            if(!world.has(key)) return;

            const block = world.get(key);
            block.parent.remove(block);
            world.delete(key);
        }

        // Optimized Player Movement with Improved Collision
        function updatePlayer(deltaTime) {
            const forward = new THREE.Vector3(
                Math.sin(player.yaw),
                0,
                Math.cos(player.yaw)
            );
            const right = new THREE.Vector3(
                Math.sin(player.yaw + Math.PI/2),
                0,
                Math.cos(player.yaw + Math.PI/2)
            );

            // Movement
            const move = new THREE.Vector3();
            if(keys.w) move.add(forward);
            if(keys.s) move.sub(forward);
            if(keys.a) move.sub(right);
            if(keys.d) move.add(right);

            move.normalize().multiplyScalar(CONFIG.MOVEMENT_SPEED);
            
            // Check horizontal collisions
            const testPos = player.position.clone().add(new THREE.Vector3(move.x, 0, move.z));
            if(!checkCollision(testPos)) {
                player.position.x = testPos.x;
                player.position.z = testPos.z;
            }

            // Gravity
            player.velocity.y -= CONFIG.GRAVITY;
            const verticalTest = player.position.clone().add(new THREE.Vector3(0, player.velocity.y, 0));
            
            // Check vertical collisions
            if(!checkCollision(verticalTest)) {
                player.position.y = verticalTest.y;
                player.onGround = false;
            } else {
                player.velocity.y = 0;
                player.onGround = true;
            }

            // Jumping
            if(keys[' '] && player.onGround) {
                player.velocity.y = CONFIG.JUMP_FORCE;
                player.onGround = false;
            }

            // Update camera
            camera.position.copy(player.position);
            camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');

            // Update chunk visibility based on player position
            updateChunkVisibility();
        }

        // Optimized Chunk Visibility
        function updateChunkVisibility() {
            const playerChunkX = Math.floor(player.position.x / CONFIG.CHUNK_SIZE);
            const playerChunkZ = Math.floor(player.position.z / CONFIG.CHUNK_SIZE);
            
            chunks.forEach((chunk, key) => {
                const [chunkX, chunkZ] = key.split(',').map(Number);
                const distance = Math.sqrt(
                    Math.pow(chunkX - playerChunkX, 2) + 
                    Math.pow(chunkZ - playerChunkZ, 2)
                );
                
                chunk.visible = distance <= (CONFIG.RENDER_DISTANCE / CONFIG.CHUNK_SIZE);
            });
        }

        // Optimized Collision Detection
        function checkCollision(position) {
            const playerBox = new THREE.Box3(
                new THREE.Vector3().copy(position).sub(new THREE.Vector3(0.3, 0, 0.3)),
                new THREE.Vector3().copy(position).add(new THREE.Vector3(0.3, CONFIG.PLAYER_HEIGHT, 0.3))
            );

            // Only check nearby blocks for collision
            const minX = Math.floor(position.x - 1);
            const maxX = Math.ceil(position.x + 1);
            const minY = Math.floor(position.y - 1);
            const maxY = Math.ceil(position.y + CONFIG.PLAYER_HEIGHT + 1);
            const minZ = Math.floor(position.z - 1);
            const maxZ = Math.ceil(position.z + 1);

            for(let x = minX; x <= maxX; x++) {
                for(let y = minY; y <= maxY; y++) {
                    for(let z = minZ; z <= maxZ; z++) {
                        const key = `${x},${y},${z}`;
                        if(world.has(key)) {
                            const block = world.get(key);
                            const blockBox = new THREE.Box3().setFromObject(block);
                            if(playerBox.intersectsBox(blockBox)) return true;
                        }
                    }
                }
            }
            return false;
        }

        // Event Listeners
        function setupEventListeners() {
            document.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;
                if(e.key === 'Escape') toggleOptions();
            });
            
            document.addEventListener('keyup', e => {
                keys[e.key.toLowerCase()] = false;
            });
            
            document.addEventListener('click', () => {
                if(!document.pointerLockElement) {
                    document.body.requestPointerLock();
                } else {
                    handleBlockInteraction();
                }
            });

            document.addEventListener('mousemove', e => {
                if(document.pointerLockElement === document.body) {
                    player.yaw -= e.movementX * CONFIG.MOUSE_SENSITIVITY;
                    player.pitch -= e.movementY * CONFIG.MOUSE_SENSITIVITY;
                    player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.pitch));
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function setupMenuButtons() {
            document.getElementById('saveBtn').addEventListener('click', saveGameToFile);
            document.getElementById('loadBtn').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });
            
            document.getElementById('fileInput').addEventListener('change', loadGameFromFile);
        }

        function handleBlockInteraction() {
            raycaster.setFromCamera(new THREE.Vector2(), camera);
            const intersects = raycaster.intersectObjects([...world.values()]);
            
            if(intersects.length > 0) {
                const block = intersects[0].object;
                const type = document.getElementById('blockType').value;
                
                if(event.button === 0) { // Left click - break block
                    removeBlock(block.position.x, block.position.y, block.position.z);
                } else if(event.button === 2) { // Right click - place block
                    const faceNormal = intersects[0].face.normal;
                    const pos = block.position.clone().add(faceNormal);
                    addBlock(pos.x, pos.y, pos.z, type);
                }
            }
        }

        function toggleOptions() {
            const menu = document.getElementById('optionsMenu');
            menu.style.display = menu.style.display === 'flex' ? 'none' : 'flex';
        }

        function closeOptions() {
            document.getElementById('optionsMenu').style.display = 'none';
        }

        function saveGameToFile() {
            const data = {
                player: {
                    position: player.position.toArray(),
                    yaw: player.yaw,
                    pitch: player.pitch
                },
                world: Array.from(world.entries()).map(([key, block]) => ({
                    key,
                    type: block.userData.type,
                    position: block.position.toArray()
                }))
            };
            
            const compressed = LZString.compress(JSON.stringify(data));
            const blob = new Blob([compressed], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `gaycraft_save_${new Date().toISOString().slice(0,10)}.gaycraft`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('Game saved to file!');
        }

        function loadGameFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const compressed = e.target.result;
                    const data = JSON.parse(LZString.decompress(compressed));
                    
                    // Clear existing world
                    world.forEach(block => {
                        if(block.parent) block.parent.remove(block);
                    });
                    world.clear();
                    chunks.clear();
                    
                    // Load player state
                    player.position.fromArray(data.player.position);
                    player.yaw = data.player.yaw;
                    player.pitch = data.player.pitch;
                    
                    // Load world
                    data.world.forEach(blockData => {
                        const pos = new THREE.Vector3().fromArray(blockData.position);
                        addBlock(pos.x, pos.y, pos.z, blockData.type);
                    });
                    
                    alert('Game loaded from file!');
                } catch(e) {
                    console.error('Load error:', e);
                    alert('Failed to load game file!');
                }
            };
            reader.readAsText(file);
        }

        // Optimized Game Loop
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            // Calculate delta time for smooth movement
            const deltaTime = Math.min(0.1, (time - lastTime) / 1000);
            lastTime = time;
            
            updatePlayer(deltaTime);
            renderer.render(scene, camera);
        }

        // Start the game
        init();
    </script>
</body>
</html>
