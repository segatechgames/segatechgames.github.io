<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GayCraft 2.0.0</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Arial', sans-serif; }
        canvas { display: block; }
        #ui { position: fixed; top: 0; left: 0; padding: 1rem; z-index: 100; color: white; pointer-events: none; }
        #blockPicker { background: rgba(0,0,0,0.7); padding: 0.5rem; border-radius: 4px; pointer-events: all; }
        #watermark { position: fixed; top: 10px; right: 10px; font-size: 1.5em; font-weight: bold;
            background: linear-gradient(90deg, #ff0000, #ff8000, #ffff00, #00ff00, #00ffff, #8000ff);
            -webkit-background-clip: text; background-clip: text; color: transparent; }
        #crosshair { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            width: 4px; height: 4px; background: rgba(255,255,255,0.9); border-radius: 50%; }
        #optionsMenu { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            background: rgba(0,0,0,0.9); padding: 1.5rem; border-radius: 8px; color: white; display: none;
            gap: 0.5rem; flex-direction: column; z-index: 1000; }
        button { padding: 0.5rem 1rem; background: #444; border: none; color: white; border-radius: 4px;
            cursor: pointer; transition: background 0.2s; }
        button:hover { background: #666; }
        select { padding: 0.25rem; background: #333; color: white; border: none; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="blockPicker">
            Block: <select id="blockType">
                <option value="grass">Grass</option>
                <option value="stone">Stone</option>
                <option value="dirt">Dirt</option>
                <option value="sand">Sand</option>
                <option value="wood">Wood</option>
                <option value="leaves">Leaves</option>
            </select>
        </div>
        <div id="watermark">GayCraft 2.0</div>
    </div>
    <div id="crosshair"></div>
    <div id="optionsMenu">
        <button onclick="saveGame()">Save Game</button>
        <button onclick="loadGame()">Load Game</button>
        <button onclick="window.location.href='https://segatechgames.github.io/'">Exit</button>
        <button onclick="closeOptions()">Close</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

    <script>
        // Enhanced Configuration
        const CONFIG = {
            WORLD_SIZE: 128,  // Larger world
            PLAYER_HEIGHT: 1.8,
            MOVEMENT_SPEED: 0.15,
            JUMP_FORCE: 0.35,
            GRAVITY: 0.02,
            MOUSE_SENSITIVITY: 0.002,
            TREE_DENSITY: 0.02
        };

        // Core Game State
        let scene, camera, renderer, world = new Map();
        let player = { 
            position: new THREE.Vector3(0, 32, 0),
            velocity: new THREE.Vector3(),
            yaw: 0,
            pitch: 0,
            onGround: false,
            inventory: {}
        };
        let keys = {}, mouseDelta = new THREE.Vector2(), raycaster = new THREE.Raycaster();

        // Initialize Game
        function init() {
            try {
                // Scene Setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87ceeb);
                
                // Camera Setup
                camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.copy(player.position);
                
                // Renderer Setup
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                // Enhanced Lighting
                scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(100, 100, 50);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                // Generate Beautiful World
                generateEnhancedWorld();
                setupEventListeners();
                animate();

            } catch (error) {
                console.error("Initialization error:", error);
                alert("Game failed to initialize. Check console for details.");
            }
        }

        // Enhanced World Generation with Trees
        function generateEnhancedWorld() {
            const materials = {
                grass: new THREE.MeshLambertMaterial({ color: 0x55aa44 }),
                stone: new THREE.MeshLambertMaterial({ color: 0x999999 }),
                dirt: new THREE.MeshLambertMaterial({ color: 0x886633 }),
                sand: new THREE.MeshLambertMaterial({ color: 0xffdd99 }),
                wood: new THREE.MeshLambertMaterial({ color: 0x774411 }),
                leaves: new THREE.MeshLambertMaterial({ color: 0x33aa33, transparent: true, opacity: 0.8 })
            };

            const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
            
            // Generate terrain with height variation
            for(let x = -CONFIG.WORLD_SIZE; x <= CONFIG.WORLD_SIZE; x++) {
                for(let z = -CONFIG.WORLD_SIZE; z <= CONFIG.WORLD_SIZE; z++) {
                    // Create height variation
                    const height = Math.floor(Math.sin(x/10) * Math.cos(z/10) * 3) + 5;
                    
                    // Ground layers
                    addBlock(x, height, z, 'grass', materials.grass, blockGeometry);
                    addBlock(x, height-1, z, 'dirt', materials.dirt, blockGeometry);
                    for(let y = height-2; y >= height-4; y--) {
                        addBlock(x, y, z, 'dirt', materials.dirt, blockGeometry);
                    }
                    for(let y = height-5; y >= -5; y--) {
                        addBlock(x, y, z, 'stone', materials.stone, blockGeometry);
                    }

                    // Random trees
                    if(Math.random() < CONFIG.TREE_DENSITY && height > 0) {
                        generateTree(x, height+1, z, materials, blockGeometry);
                    }
                }
            }
        }

        // Tree Generator
        function generateTree(x, y, z, materials, geometry) {
            // Trunk
            for(let i = 0; i < 5; i++) {
                addBlock(x, y+i, z, 'wood', materials.wood, geometry);
            }
            
            // Leaves
            for(let lx = -2; lx <= 2; lx++) {
                for(let lz = -2; lz <= 2; lz++) {
                    for(let ly = 3; ly <= 6; ly++) {
                        // Skip corners for better looking trees
                        if(Math.abs(lx) === 2 && Math.abs(lz) === 2 && Math.random() > 0.5) continue;
                        addBlock(x+lx, y+ly, z+lz, 'leaves', materials.leaves, geometry);
                    }
                }
            }
        }

        // Block Management
        function addBlock(x, y, z, type, material, geometry) {
            const key = `${x},${y},${z}`;
            if(world.has(key)) return;

            const block = new THREE.Mesh(geometry, material);
            block.position.set(x, y, z);
            block.userData = { type };
            scene.add(block);
            world.set(key, block);
        }

        // Improved Player Movement with Collision
        function updatePlayer(deltaTime) {
            const forward = new THREE.Vector3(
                Math.sin(player.yaw),
                0,
                Math.cos(player.yaw)
            );
            const right = new THREE.Vector3(
                Math.sin(player.yaw + Math.PI/2),
                0,
                Math.cos(player.yaw + Math.PI/2)
            );

            // Movement
            const move = new THREE.Vector3();
            if(keys.w) move.add(forward);
            if(keys.s) move.sub(forward);
            if(keys.a) move.sub(right);
            if(keys.d) move.add(right);

            move.normalize().multiplyScalar(CONFIG.MOVEMENT_SPEED);
            
            // Check horizontal collisions
            const testPos = player.position.clone().add(new THREE.Vector3(move.x, 0, move.z));
            if(!checkCollision(testPos)) {
                player.position.x = testPos.x;
                player.position.z = testPos.z;
            }

            // Gravity
            player.velocity.y -= CONFIG.GRAVITY;
            const verticalTest = player.position.clone().add(new THREE.Vector3(0, player.velocity.y, 0));
            
            // Check vertical collisions
            if(!checkCollision(verticalTest)) {
                player.position.y = verticalTest.y;
                player.onGround = false;
            } else {
                player.velocity.y = 0;
                player.onGround = true;
            }

            // Jumping
            if(keys[' '] && player.onGround) {
                player.velocity.y = CONFIG.JUMP_FORCE;
                player.onGround = false;
            }

            // Update camera
            camera.position.copy(player.position);
            camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
        }

        // Precise Collision Detection
        function checkCollision(position) {
            const playerBox = new THREE.Box3(
                new THREE.Vector3().copy(position).sub(new THREE.Vector3(0.3, 0, 0.3)),
                new THREE.Vector3().copy(position).add(new THREE.Vector3(0.3, CONFIG.PLAYER_HEIGHT, 0.3))
            );

            for(const block of world.values()) {
                const blockBox = new THREE.Box3().setFromObject(block);
                if(playerBox.intersectsBox(blockBox)) return true;
            }
            return false;
        }

        // Event Listeners
        function setupEventListeners() {
            document.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;
                if(e.key === 'Escape') toggleOptions();
            });
            
            document.addEventListener('keyup', e => {
                keys[e.key.toLowerCase()] = false;
            });
            
            document.addEventListener('click', () => {
                if(!document.pointerLockElement) {
                    document.body.requestPointerLock();
                } else {
                    handleBlockInteraction();
                }
            });

            document.addEventListener('mousemove', e => {
                if(document.pointerLockElement === document.body) {
                    player.yaw -= e.movementX * CONFIG.MOUSE_SENSITIVITY;
                    player.pitch -= e.movementY * CONFIG.MOUSE_SENSITIVITY;
                    player.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.pitch));
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Block Interaction
        function handleBlockInteraction() {
            raycaster.setFromCamera(new THREE.Vector2(), camera);
            const intersects = raycaster.intersectObjects([...world.values()]);
            
            if(intersects.length > 0) {
                const block = intersects[0].object;
                const type = document.getElementById('blockType').value;
                
                // Left click - break block
                if(event.button === 0) {
                    removeBlock(block.position.x, block.position.y, block.position.z);
                } 
                // Right click - place block
                else if(event.button === 2) {
                    const faceNormal = intersects[0].face.normal;
                    const pos = block.position.clone().add(faceNormal);
                    addBlock(pos.x, pos.y, pos.z, type);
                }
            }
        }

        // Game Loop
        function animate() {
            requestAnimationFrame(animate);
            updatePlayer(0.016); // Fixed delta time
            renderer.render(scene, camera);
        }

        // Start the game
        init();
    </script>
</body>
</html>
