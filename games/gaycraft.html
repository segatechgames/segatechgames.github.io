<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GayCraft 1.6.20</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }

        canvas {
            display: block;
        }

        #ui {
            position: fixed;
            top: 0;
            left: 0;
            padding: 1rem;
            z-index: 100;
            color: white;
            pointer-events: none;
        }

        #blockPicker {
            background: rgba(0, 0, 0, 0.7);
            padding: 0.5rem;
            border-radius: 4px;
            pointer-events: all;
        }

        #watermark {
            position: fixed;
            top: 10px;
            right: 10px;
            font-size: 1.5em;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            background: linear-gradient(
                90deg,
                #ff0000 0%,
                #ff8000 20%,
                #ffff00 40%,
                #00ff00 60%,
                #00ffff 80%,
                #8000ff 100%
            );
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
        }

        #optionsMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 1.5rem;
            border-radius: 8px;
            color: white;
            display: none;
            gap: 0.5rem;
            flex-direction: column;
            z-index: 1000;
        }

        #optionsMenu button {
            padding: 0.5rem 1rem;
            background: #444;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        #optionsMenu button:hover {
            background: #666;
        }

        select {
            padding: 0.25rem;
            background: #333;
            color: white;
            border: none;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="blockPicker">
            Block: 
            <select id="blockType">
                <option value="grass">Grass</option>
                <option value="stone">Stone</option>
                <option value="dirt">Dirt</option>
                <option value="sand">Sand</option>
                <option value="wood">Wood</option>
                <option value="leaves">Leaves</option>
            </select>
        </div>
        <div id="watermark">GayCraft 1.6.20</div>
    </div>

    <div id="crosshair"></div>
    <div id="optionsMenu">
        <button onclick="saveGame()">Save Game</button>
        <button onclick="loadGame()">Load Game</button>
        <button onclick="window.location.href='https://segatechgames.github.io/'">Exit</button>
        <button onclick="closeOptions()">Close</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

    <script>
        // Game Configuration
        const CONFIG = {
            WORLD_SIZE: 32,
            BLOCK_SIZE: 1,
            MOVEMENT_SPEED: 5,
            JUMP_FORCE: 8,
            GRAVITY: 30,
            MOUSE_SENSITIVITY: 0.002,
            PLAYER_HEIGHT: 1.8
        };

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        
        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 16, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(100, 100, 50);
        scene.add(directionalLight);

        // Textures (Color Placeholders)
        const createColorTexture = (color) => {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 16;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 16, 16);
            return new THREE.CanvasTexture(canvas);
        };

        const materials = {
            grass: new THREE.MeshLambertMaterial({ map: createColorTexture('#00aa00') }),
            stone: new THREE.MeshLambertMaterial({ map: createColorTexture('#888888') }),
            dirt: new THREE.MeshLambertMaterial({ map: createColorTexture('#664411') }),
            sand: new THREE.MeshLambertMaterial({ map: createColorTexture('#ffff99') }),
            wood: new THREE.MeshLambertMaterial({ map: createColorTexture('#996633') }),
            leaves: new THREE.MeshLambertMaterial({ 
                map: createColorTexture('#00cc00'),
                transparent: true,
                alphaTest: 0.5
            }),
        };

        // World Data
        const world = new Map();
        const blockGeometry = new THREE.BoxGeometry(CONFIG.BLOCK_SIZE, CONFIG.BLOCK_SIZE, CONFIG.BLOCK_SIZE);

        // Player State
        const player = {
            position: new THREE.Vector3(0, 16, 0),
            velocity: new THREE.Vector3(),
            yaw: 0,
            pitch: 0,
            onGround: false
        };

        // Controls
        const keys = {};
        let mouseDelta = new THREE.Vector2();
        let highlightCube = null;

        // Generate World
        function generateWorld() {
            for(let x = -CONFIG.WORLD_SIZE; x <= CONFIG.WORLD_SIZE; x++) {
                for(let z = -CONFIG.WORLD_SIZE; z <= CONFIG.WORLD_SIZE; z++) {
                    addBlock(x, 0, z, 'grass');
                    for(let y = -1; y >= -3; y--) {
                        addBlock(x, y, z, 'dirt');
                    }
                }
            }
        }

        // Block Management
        function addBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            if(world.has(key)) return;

            const block = new THREE.Mesh(blockGeometry, materials[type]);
            block.position.set(x, y, z);
            block.userData = { type };
            scene.add(block);
            world.set(key, block);
        }

        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            const block = world.get(key);
            if(block) {
                scene.remove(block);
                world.delete(key);
            }
        }

        // Player Movement
        function updatePlayer(deltaTime) {
            // Rotation
            player.yaw -= mouseDelta.x * CONFIG.MOUSE_SENSITIVITY;
            player.pitch -= mouseDelta.y * CONFIG.MOUSE_SENSITIVITY;
            player.pitch = THREE.MathUtils.clamp(player.pitch, -Math.PI/2, Math.PI/2);
            mouseDelta.set(0, 0);

            // Movement
            const forward = new THREE.Vector3(
                Math.sin(player.yaw),
                0,
                Math.cos(player.yaw)
            );
            
            const right = new THREE.Vector3(
                Math.sin(player.yaw + Math.PI/2),
                0,
                Math.cos(player.yaw + Math.PI/2)
            );

            const move = new THREE.Vector3();
            if(keys.w) move.add(forward);
            if(keys.s) move.sub(forward);
            if(keys.a) move.sub(right);
            if(keys.d) move.add(right);
            
            move.normalize().multiplyScalar(CONFIG.MOVEMENT_SPEED * deltaTime);
            player.velocity.x = move.x;
            player.velocity.z = move.z;

            // Gravity
            player.velocity.y -= CONFIG.GRAVITY * deltaTime;
            
            // Collision
            const nextPos = player.position.clone().add(player.velocity.clone().multiplyScalar(deltaTime));
            if(!checkCollision(nextPos)) {
                player.position.copy(nextPos);
                player.onGround = false;
            } else {
                player.velocity.y = 0;
                player.onGround = true;
            }

            // Jump
            if(keys[' '] && player.onGround) {
                player.velocity.y = CONFIG.JUMP_FORCE;
                player.onGround = false;
            }

            // Update Camera
            camera.position.copy(player.position);
            camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
        }

        function checkCollision(position) {
            const playerBox = new THREE.Box3(
                new THREE.Vector3().copy(position).sub(new THREE.Vector3(0.3, 0, 0.3)),
                new THREE.Vector3().copy(position).add(new THREE.Vector3(0.3, CONFIG.PLAYER_HEIGHT, 0.3))
            );

            for(const block of world.values()) {
                const blockBox = new THREE.Box3().setFromObject(block);
                if(playerBox.intersectsBox(blockBox)) return true;
            }
            return false;
        }

        // Block Interaction
        function updateBlockHighlight() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(), camera);
            const intersects = raycaster.intersectObjects([...world.values()]);
            
            if(highlightCube) scene.remove(highlightCube);
            
            if(intersects.length > 0) {
                const intersect = intersects[0];
                const faceNormal = intersect.face.normal;
                const placePos = intersect.object.position.clone().add(faceNormal);
                
                highlightCube = new THREE.Mesh(
                    blockGeometry,
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffff00,
                        transparent: true,
                        opacity: 0.5
                    })
                );
                highlightCube.position.copy(placePos);
                scene.add(highlightCube);
            }
        }

        // Save/Load System
        function saveGame() {
            const saveData = Array.from(world.values()).map(block => ({
                type: block.userData.type,
                position: [block.position.x, block.position.y, block.position.z]
            }));
            
            const compressed = LZString.compressToUTF16(JSON.stringify(saveData));
            const blob = new Blob([compressed], { type: 'application/octet-stream' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `GayCraft-Save-${new Date().toISOString().slice(0,10)}.gcsave`;
            link.click();
        }

        function loadGame() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.gcsave';
            input.onchange = e => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = event => {
                    const data = LZString.decompressFromUTF16(event.target.result);
                    const saveData = JSON.parse(data);
                    
                    // Clear existing world
                    world.forEach(block => scene.remove(block));
                    world.clear();
                    
                    // Load new blocks
                    saveData.forEach(block => {
                        addBlock(...block.position, block.type);
                    });
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // Menu Controls
        function toggleOptions() {
            const menu = document.getElementById('optionsMenu');
            menu.style.display = menu.style.display === 'none' ? 'flex' : 'none';
        }

        function closeOptions() {
            document.getElementById('optionsMenu').style.display = 'none';
        }

        // Event Listeners
        document.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if(e.key === 'Escape') toggleOptions();
        });
        
        document.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
        });

        document.addEventListener('mousedown', e => {
            if(document.pointerLockElement !== document.body) {
                document.body.requestPointerLock();
            } else {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(), camera);
                const intersects = raycaster.intersectObjects([...world.values()]);
                
                if(intersects.length > 0) {
                    const block = intersects[0].object;
                    if(e.button === 0) { // Left click
                        removeBlock(block.position.x, block.position.y, block.position.z);
                    } else if(e.button === 2) { // Right click
                        const faceNormal = intersects[0].face.normal;
                        const pos = block.position.clone().add(faceNormal);
                        const type = document.getElementById('blockType').value;
                        addBlock(pos.x, pos.y, pos.z, type);
                    }
                }
            }
        });

        document.addEventListener('mousemove', e => {
            if(document.pointerLockElement === document.body) {
                mouseDelta.set(e.movementX, e.movementY);
            }
        });

        document.addEventListener('contextmenu', e => e.preventDefault());

        // Game Loop
        let lastTime = 0;
        function animate(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            
            updatePlayer(deltaTime);
            updateBlockHighlight();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // Initialization
        generateWorld();
        animate();

        // Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
